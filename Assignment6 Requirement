The provided code (sortTimer.cpp) has the STL sort algorithms sort (merge sort and quick sort) and sort_heap (heap sort) implemented in the code. Make a table (excel or in word) of the run times of the sorts for 1000 elements, 10,000 elements, 100,000 elements, 1,000,000 elements and 10,000,000 elements. Record how long the sort takes for each of the instances.

Both algorithms should have O(n log n) performance, do they?

How do you know? (Answer these questions in your documentation)

Part 2: Add another sort algorithm 25pts
Create your own sort algorithm (insert sort, bubble sort, selection sort or cocktail sort) and measure the run time of the algorithm using the same number as elements as you did for part 1.

Answer the following questions:

What algorithm did you pick?

What is the complexity of the algorithm you picked?

Does the performance seem to match that performance?

Extra Credit 5 points per algorithm

Add addition sorting algorithms you created (you may also want to try some exotic sorts like bogosort and stoogesort)

Measure the performance and calculate the complexity.

Part 3: Ordered sort values (25 pts)
The quick sort has poor performance when the list is nearly ordered. Instead of passing sort() a random list pass it an ordered list and see what the run time performance is compared to the other algorithms implemented in parts 1 and 2.

Is the performance significantly different than before? Why or why not?

What to turn in:
Your documentation of the performance and questions answered, and final C++ file.
